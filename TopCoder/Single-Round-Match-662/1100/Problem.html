<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>Fox Ciel is creating a new binary operation.
<br></br>
<br></br>
The operation will be denoted * and it will be defined on the finite set S = {0, 1, 2, ..., n-1}.
I.e., for each ordered pair of elements of S the operation will return some element of S.
The operation can be described by its "multiplication table": a square table where in row i and column j we have the result returned by the operation i*j.
Ciel has already filled in row 0 of this table: for each j we know that 0 * j = <b>firstRow</b>[j].
<br></br>
<br></br>
Ciel's operation doesn't have to be symmetric: it is possible that for some i and j the operations i*j and j*i return two different values.
However, Ciel does want her operation to be associative: for all a,b,c in S, (a*b)*c must be equal to a*(b*c).
(Note that this includes cases when some or all of a,b,c are equal to each other.)
<br></br>
<br></br>
You are given the vector &lt;int&gt; <b>firstRow</b> with n elements.
If there is a way to fill in the rest of the multiplication table so that the resulting operation is associative, find one such way and return a vector &lt;int&gt; with n*n elements: all elements of the entire multiplication table, listed in row major order.
If there are multiple solutions you may return any of them.
If there are no solutions, return {-1}.
(I.e., if there are no solutions, return a vector &lt;int&gt; of length 1 containing the element -1.)</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>MultiplicationTable</td></tr><tr><td>Method:</td><td>getMultiplicationTable</td></tr><tr><td>Parameters:</td><td>vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>vector &lt;int&gt;</td></tr><tr><td>Method signature:</td><td>vector &lt;int&gt; getMultiplicationTable(vector &lt;int&gt; firstRow)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>firstRow</b> will contain between 2 and 50 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element in <b>firstRow</b> will be between 0 and |<b>firstRow</b>|-1, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,2,0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {1, 2, 0, 2, 0, 1, 0, 1, 2 }</pre></td></tr><tr><td><table><tr><td colspan="2">The example return value corresponds to the following multiplication table:

<pre>
* | 0  1  2
--+-----------
0 | 1  2  0
1 | 2  0  1
2 | 0  1  2  
</pre>

In other words, this operation * can be defined using the following formula: i*j = (i+j+1) mod 3.
We can easily verify that for any a,b,c both (a*b)*c and a*(b*c) evaluates to the same value: namely, to the value (a+b+c+2) mod 3.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,1,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {1, 1, 1, 1, 1, 1, 1, 1, 1 }</pre></td></tr><tr><td><table><tr><td colspan="2">This time we can use: i*j = 1.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,0,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {-1 }</pre></td></tr><tr><td><table><tr><td colspan="2">Row 0 already tells us that 0*0 = 0, 0*1 = 0, and 0*2 = 1.
Let's take a=0, b=0, and c=2.
On one hand we already know that (a*b)*c = (0*0)*2 = 0*2 = 1.
On the other hand we also know that a*(b*c) = 0*(0*2) = 0*1 = 0.
Hence, regardless of how we fill in the rest of the table, the resulting operation will never be associative.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {0, 1, 1, 1 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{2,3,0,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {2, 3, 0, 1, 3, 0, 1, 2, 0, 1, 2, 3, 1, 2, 3, 0 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{3,4,5,0,2,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {-1 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">6)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1,2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {0, 1, 2, 0, 1, 2, 0, 1, 2 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>